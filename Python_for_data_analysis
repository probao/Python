###################################
###numpy基础：数组和矢量的计算#####
###################################


创建ndarray
>>> import numpy as np
>>> data1 = [6, 7.5, 8, 0, 1]
>>> arr1 = np.array(data1)	# 使用array函数，它接受一切序列型的对象，产生一个含有传入数据的numpy数组
>>> arr1
array([ 6. ,  7.5,  8. ,  0. ,  1. ])


嵌套序列
>>> data2 = [[1,2,3,4], [5, 6, 7, 8]]
>>> arr2 = np.array(data2)
>>> arr2
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])
>>> arr2.ndim	# 数组的维数
2
>>> arr2.shape	# 2行4列的数组
(2, 4)

>>> arr1.dtype	# 数据类型保存在一个特殊的dtype对象中
dtype('float64')
>>> arr2.dtype
dtype('int32')


其它函数新建数组
>>> np.zeros(10)	# 生成全是0的数组
array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
>>> np.zeros((3, 6))
array([[ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.]])
>>> np.ones((3, 6))	# 生成全是1的数组
array([[ 1.,  1.,  1.,  1.,  1.,  1.],
       [ 1.,  1.,  1.,  1.,  1.,  1.],
       [ 1.,  1.,  1.,  1.,  1.,  1.]])
>>> np.empty((2, 3, 2))		# 生成的不是0， 是一些未被处理的垃圾值
array([[[  1.03510883e-295,   6.38742701e-314],
        [  1.55420853e-285,   1.27319747e-313],
        [  1.27319747e-313,   1.27319747e-313]],

       [[  2.37332014e-286,   1.91205622e-313],
        [  8.13462439e-296,   2.75859453e-313],
        [  2.48324480e-286,   3.12237178e-120]]])

>>> np.arange(15)		# arange是python内置函数range的数组版
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])

>>> np.eye(3)			# 对角线是1的数组
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])


ndarray的数据类型
>>> arr1 = np.array([1, 2, 3], dtype=np.float64)
>>> arr2 = np.array([1, 2, 3], dtype=np.int32)
>>> arr1.dtype
dtype('float64')
>>> arr2.dtype
dtype('int32')



数组和标量之间的运算
>>> arr = np.array([[1., 2., 3.], [4., 5., 6.]])
>>> arr
array([[ 1.,  2.,  3.],
       [ 4.,  5.,  6.]])
>>> arr*arr
array([[  1.,   4.,   9.],	#大小相等的数组的任何运算都会将运算运用到元素级
       [ 16.,  25.,  36.]])
>>> 1/arr
array([[ 1.        ,  0.5       ,  0.33333333],
       [ 0.25      ,  0.2       ,  0.16666667]])
>>> arr**0.5
array([[ 1.        ,  1.41421356,  1.73205081],
       [ 2.        ,  2.23606798,  2.44948974]])

>>> a = np.array([[1,2],[1,2]])	#矩阵的运算需要dot函数
>>> np.dot(a,a)
array([[3, 6],
       [3, 6]])


基本的索引和切片
>>> import numpy as np
>>> arr = np.arange(10)
>>> arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>>
>>>
>>> arr[5]
5
>>>
>>> arr[5:8]
array([5, 6, 7])
>>> arr[5:8] = 12
>>> arr
array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9]) # 当一个标量值赋值给一个切片时，该值会自动传播到整个选取


>>> arr_slice = arr[5:8]
>>> arr_slice[1] = 12345
>>> arr
array([    0,     1,     2,     3,     4,    12, 12345,    12,     8,     9])
>>> arr_slice[:] = 64
>>> arr
array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])


>>> arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])	# 多维数组索引
>>> arr2d[2]
array([7, 8, 9])
>>> arr2d[0][2]
3
>>> arr2d[0, 2]
3


>>> arr3d = np.array([[[1, 2, 3], [4, 5, 6]],[[7, 8, 9], [10, 11, 12]]])
>>> arr3d	# 括号外面的“维度”是一维，二维，。。。而括号里面的应该理解为“轴”--类比三维数组
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
>>> arr3d [0]
array([[1, 2, 3],
       [4, 5, 6]])



>>> old_values = arr3d[0].copy()
>>>
>>> arr3d[0] = 42
>>> arr3d
array([[[42, 42, 42],
        [42, 42, 42]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
>>> arr3d[0] = old_values	# 标量和数组都可以被赋值给arr3d[0]
>>> arr3d
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

>>> arr3d[1, 0]
array([7, 8, 9])

切片索引

>>> arr
array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])
>>> arr[1:6]
array([ 1,  2,  3,  4, 64])


>>> arr2d
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
>>> arr2d[:2]	#[:2]意思是--第0项和第1项
array([[1, 2, 3],
       [4, 5, 6]])
>>> arr2d[:2, 1:]	# [1:] 第一项到最后
array([[2, 3],
       [5, 6]])


>>> arr2d[1, :2]
array([4, 5])
>>> arr2d[2, :1]
array([7])
>>> arr2d[:, :1]	
array([[1],
       [4],
       [7]])
>>> arr2d[:2, 1:]
array([[2, 3],
       [5, 6]])
>>> arr2d[:2, 1:] = 0	#对切片表达式的赋值操作也会被扩赛到整个选区
>>> arr2d
array([[1, 0, 0],
       [4, 0, 0],
       [7, 8, 9]])


布尔型索引

>>> data = np.random.randn(7, 4)
>>> data
array([[-0.31042535, -2.17572506,  0.56252532,  0.99534791],
       [ 0.63397486, -0.13189191,  0.29471484,  0.50351773],
       [ 0.51495017,  0.04994144, -0.1762269 , -0.19449053],
       [-0.07743183, -0.42964157, -1.39686796, -1.11814711],
       [-1.13909174, -0.65366514, -0.2169853 ,  0.61072596],
       [ 1.41913738, -1.2421399 ,  0.45052187, -0.17214591],
       [-0.14628746,  0.25535978, -1.04384285,  0.45418343]])
>>> names
array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
      dtype='|S4')
>>> names == 'Bob'
array([ True, False, False,  True, False, False, False], dtype=bool)
>>> data[names ==  'Bob']	# 布尔型数组可用于数组索引，布尔型数组的长度必须跟被索引的轴长度一致
array([[-0.31042535, -2.17572506,  0.56252532,  0.99534791],
       [-0.07743183, -0.42964157, -1.39686796, -1.11814711]])


>>> data[names ==  'Bob', 2:]	# 布尔型数组跟切片混合使用
array([[ 0.56252532,  0.99534791],
       [-1.39686796, -1.11814711]])

>>> data[names ==  'Bob', 3]
array([ 0.99534791, -1.11814711])

>>> names != 'Bob'	# 选择除“Bob”以外的其他值可以使用不等于符号(!=),也可以通过负号
array([False,  True,  True, False,  True,  True,  True], dtype=bool)
>>> data[-(names ==  'Bob')]
array([[ 0.63397486, -0.13189191,  0.29471484,  0.50351773],
       [ 0.51495017,  0.04994144, -0.1762269 , -0.19449053],
       [-1.13909174, -0.65366514, -0.2169853 ,  0.61072596],
       [ 1.41913738, -1.2421399 ,  0.45052187, -0.17214591],
       [-0.14628746,  0.25535978, -1.04384285,  0.45418343]])


>>> mask = (names == 'Bob')|(names == 'Will')
>>> mask
array([ True, False,  True,  True,  True, False, False], dtype=bool)
>>> mask1 = (names == 'Bob') & (names == 'Will')
>>> mask1
array([False, False, False, False, False, False, False], dtype=bool)
>>> data[mask]
array([[-0.31042535, -2.17572506,  0.56252532,  0.99534791],
       [ 0.51495017,  0.04994144, -0.1762269 , -0.19449053],
       [-0.07743183, -0.42964157, -1.39686796, -1.11814711],
       [-1.13909174, -0.65366514, -0.2169853 ,  0.61072596]])


>>> data
array([[-0.31042535, -2.17572506,  0.56252532,  0.99534791],
       [ 0.63397486, -0.13189191,  0.29471484,  0.50351773],
       [ 0.51495017,  0.04994144, -0.1762269 , -0.19449053],
       [-0.07743183, -0.42964157, -1.39686796, -1.11814711],
       [-1.13909174, -0.65366514, -0.2169853 ,  0.61072596],
       [ 1.41913738, -1.2421399 ,  0.45052187, -0.17214591],
       [-0.14628746,  0.25535978, -1.04384285,  0.45418343]])
>>>
>>> data[data < 0] = 0	#将data中的所有负值都设置为0
>>> data
array([[ 0.        ,  0.        ,  0.56252532,  0.99534791],
       [ 0.63397486,  0.        ,  0.29471484,  0.50351773],
       [ 0.51495017,  0.04994144,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.61072596],
       [ 1.41913738,  0.        ,  0.45052187,  0.        ],
       [ 0.        ,  0.25535978,  0.        ,  0.45418343]])

>>> data[names != 'Joe'] = 7	#
>>> data
array([[ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 0.63397486,  0.        ,  0.29471484,  0.50351773],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 1.41913738,  0.        ,  0.45052187,  0.        ],
       [ 0.        ,  0.25535978,  0.        ,  0.45418343]])


花式索引
>>> arr = np.empty((8,4))
>>> for i in range(8):
...     arr[i] = i
...
>>> arr
array([[ 0.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  1.],
       [ 2.,  2.,  2.,  2.],
       [ 3.,  3.,  3.,  3.],
       [ 4.,  4.,  4.,  4.],
       [ 5.,  5.,  5.,  5.],
       [ 6.,  6.,  6.,  6.],
       [ 7.,  7.,  7.,  7.]])
>>> arr[[4, 3, 0, 6]]	# 第四行，第三行，第零行 和 第六行
array([[ 4.,  4.,  4.,  4.],
       [ 3.,  3.,  3.,  3.],
       [ 0.,  0.,  0.,  0.],
       [ 6.,  6.,  6.,  6.]])

>>> arr[[-3, -5, 0, -7]]	#使用负数索引将会从末尾开始选取行
array([[ 5.,  5.,  5.,  5.],
       [ 3.,  3.,  3.,  3.],
       [ 0.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  1.]])


>>> arr = np.arange(32).reshape((8, 4)) # 一次传入多个索引数组，它返回的是一个一维数组，其中的元素对应各个索引元组
>>> arr
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])
>>> arr[[1, 5, 7, 2],[0, 3, 1, 2]]
array([ 4, 23, 29, 10])

>>> arr[[1, 5, 7, 2]][:,[0, 3, 1, 2]]	# 先取行，再取列
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])



数组转置和轴对换
>>> arr = np.arange(15).reshape((3, 5))
>>> arr
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
>>> arr.T
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])



>>> arr = np.arange(16).reshape((2, 2, 4))
>>> arr
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
>>> arr.transpose((1, 0, 2))
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])
>>> arr.transpose((1, 2, 0))
array([[[ 0,  8],
        [ 1,  9],
        [ 2, 10],
        [ 3, 11]],

       [[ 4, 12],
        [ 5, 13],
        [ 6, 14],
        [ 7, 15]]])

我说你来试一下哈：
arr1.shape 应该是(2, 2, 4) 意为 2维，2*4矩阵

arr1.transpose(*args) 里面的参数，可以这么理解，他是调换arr1.shape的顺序，咱来给arr1.shape标一下角标哈，（2[0], 2[1], 4[2]）  [ ] 里是shape的索引，对吧， 
transpose((1, 0, 2)) 的意思是 按照这个顺序 重新设置shape 也就是 （2[1], 2[0], 4[2]）

 虽然看起来 变换前后的shape都是 2,2,4  ， 但是问题来了，transpose是转置
shape按照(1,0,2)的顺序重新设置了， array里的所有元素 也要按照这个规则重新组成新矩阵

 比如 8 在arr1中的索引是 (1, 0, 0)  那么按照刚才的变换规则，就是 (0, 1, 0) 看看跟你结果arr2的位置一样了吧，依此类推...



通用函数:快速的元素级数组函数
>>> import numpy as np
>>> arr = np.arange(10)
>>> np.sqrt(arr)
array([ 0.        ,  1.        ,  1.41421356,  1.73205081,  2.        ,
        2.23606798,  2.44948974,  2.64575131,  2.82842712,  3.        ])
>>> np.exp(arr)
array([  1.00000000e+00,   2.71828183e+00,   7.38905610e+00,
         2.00855369e+01,   5.45981500e+01,   1.48413159e+02,
         4.03428793e+02,   1.09663316e+03,   2.98095799e+03,
         8.10308393e+03])
sqrt和exp是一元（unary）ufunc，另外一些（如add或maximum）接受2个数组，也叫二元数组

>>> x = np.random.randn(8)
>>> y = np.random.randn(8)
>>> x
array([-1.09442604, -1.43680231, -0.28154207,  0.84074478, -0.18878751,
        0.50501874,  0.28835676,  1.85865484])
>>> y
array([ 0.97924522, -0.94704341,  0.04190887,  1.60123804,  0.12770678,
        0.04152567, -0.11783759, -0.75930132])
>>> np.maximum(x, y)
array([ 0.97924522, -0.94704341,  0.04190887,  1.60123804,  0.12770678,
        0.50501874,  0.28835676,  1.85865484])

>>> arr = np.random.randn(7)*5
>>> arr
array([ -9.17367478,   0.71396009, -10.1828497 ,   0.45724798,
        -1.05427677,   3.08732191,  -0.73990597])
>>> np.modf(arr)	# 返回两个数组 一个是小数部分，一个是整数部分
(array([-0.17367478,  0.71396009, -0.1828497 ,  0.45724798, -0.05427677,
        0.08732191, -0.73990597]), array([ -9.,   0., -10.,   0.,  -1.,   3.,  -0.]))



利用数组进行数据处理
>>> points = np.arange(-5, 5, 0.01)
>>> xs, ys = np.meshgrid(points, points)	#生成网格，两个二维数组
>>> ys
array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
       ...,
       [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])
>>> xs
array([[-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       ...,
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99]])
>>> import matplotlib.pyplot as plt
>>> z = np.sqrt(xs**2 + ys**2)
>>> z
array([[ 7.07106781,  7.06400028,  7.05693985, ...,  7.04988652,
         7.05693985,  7.06400028],
       [ 7.06400028,  7.05692568,  7.04985815, ...,  7.04279774,
         7.04985815,  7.05692568],
       [ 7.05693985,  7.04985815,  7.04278354, ...,  7.03571603,
         7.04278354,  7.04985815],
       ...,
       [ 7.04988652,  7.04279774,  7.03571603, ...,  7.0286414 ,
         7.03571603,  7.04279774],
       [ 7.05693985,  7.04985815,  7.04278354, ...,  7.03571603,
         7.04278354,  7.04985815],
       [ 7.06400028,  7.05692568,  7.04985815, ...,  7.04279774,
         7.04985815,  7.05692568]])
>>> plt.imshow(z, cmap=plt.cm.gray);plt.colorbar()
<matplotlib.image.AxesImage object at 0x062666B0>
<matplotlib.colorbar.Colorbar object at 0x062BE0D0>
>>> plt.show()


将条件逻辑表述为数组运算
假设我们要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值
否则从yarr中选取
>>> import numpy as np
>>> xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
>>> yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
>>> cond = np.array([True, False, True, True, False])
>>> result = np.where(cond, xarr, yarr)
>>> result
array([ 1.1,  2.2,  1.3,  1.4,  2.5])

np.where的第二个和第三个参数不必是数组，它们都是可以是标量值。在数据分析工作中
，where通常用于根据另一个数组而产生一个新的数组。


>>> arr = np.random.randn(4,4)
>>> arr
array([[-0.32285005,  0.25847681,  0.66953569,  1.7002404 ],
       [ 0.22827269,  1.02391622, -0.8919314 ,  0.38018606],
       [ 0.3845627 ,  0.84781941, -0.28423424,  1.73434853],
       [-0.76948816,  0.36355368,  1.56517939,  0.00546952]])
>>> np.where(arr > 0, 2, -2)	# 将数组中大于零的换成2，小于零的换成-2
array([[-2,  2,  2,  2],
       [ 2,  2, -2,  2],
       [ 2,  2, -2,  2],
       [-2,  2,  2,  2]])
>>> np.where(arr > 0, 2, arr)	# 只将数组中大于零的换成2
array([[-0.32285005,  2.        ,  2.        ,  2.        ],
       [ 2.        ,  2.        , -0.8919314 ,  2.        ],
       [ 2.        ,  2.        , -0.28423424,  2.        ],
       [-0.76948816,  2.        ,  2.        ,  2.        ]])



数学和统计方法
>>> arr = np.random.randn(5,4)
>>> arr
array([[-1.71504642,  0.22678685,  0.74513757,  1.70279446],
       [-0.34902157,  0.27176852, -1.52373216, -0.24647356],
       [-0.49901881, -0.11396496, -0.00902927, -0.30132351],
       [-0.44314036, -0.10644648, -1.3300278 , -3.00895452],
       [-0.26927576, -0.61164494, -1.39029488, -0.08084923]])
>>> arr.mean()		# 数组的平均数
-0.45258784121946649
>>> np.mean(arr)	# 数组的平均数
-0.45258784121946649
>>> arr.sum()
-9.0517568243893294	# 数组的和
>>> arr
array([[-1.71504642,  0.22678685,  0.74513757,  1.70279446],
       [-0.34902157,  0.27176852, -1.52373216, -0.24647356],
       [-0.49901881, -0.11396496, -0.00902927, -0.30132351],
       [-0.44314036, -0.10644648, -1.3300278 , -3.00895452],
       [-0.26927576, -0.61164494, -1.39029488, -0.08084923]])
>>> arr.mean(axis = 1)		# 每一行的平均数
array([ 0.23991811, -0.46186469, -0.23083414, -1.22214229, -0.5880162 ])
>>> arr.mean(axis = 0)		# 每一列的平均数
array([-0.65510058, -0.0667002 , -0.70158931, -0.38696127])


>>> arr = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
>>> arr.cumsum(0)	# 沿列的方向 每一行加下一行
array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]])
>>> arr.cumsum(1)	# 沿行的方向 每一列加下一列
array([[ 0,  1,  3],
       [ 3,  7, 12],
       [ 6, 13, 21]])
>>> arr.cumprod(1)
array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]])
>>> arr.cumprod(0)
array([[ 0,  1,  2],
       [ 0,  4, 10],
       [ 0, 28, 80]])


用于布尔型数组的方法
>>> import numpy as np
>>> arr = np.random.randn(100)
>>> (arr > 0).sum()	# sum经常被用来对布尔型数组
58

>>> bools = np.array([False, False, True, False])
>>> bools.any()	# 用于测试有一个或多个True
True
>>> bools.all()	# 用于测试数组中是否全是True
False
这两个方法也能用于非布尔型数组，所有非0元素会被当做True


排序
>>> arr = np.random.randn(8)
>>> arr
array([-1.50790127, -1.22640436, -0.00729792, -0.42537421, -0.93833854,
       -0.6814844 ,  1.32235945, -0.09862056])
>>> arr.sort()
>>> arr
array([-1.50790127, -1.22640436, -0.93833854, -0.6814844 , -0.42537421,
       -0.09862056, -0.00729792,  1.32235945])


>>> arr = np.random.randn(3,3)
>>> arr
array([[-1.61589688, -0.65173118,  0.14666864],
       [ 0.87499686,  0.50801178, -0.06954368],
       [ 1.0262651 ,  1.08821325, -0.45640651]])
>>> arr.sort(1)		# 水平轴向sort
>>> arr
array([[-1.61589688, -0.65173118,  0.14666864],
       [-0.06954368,  0.50801178,  0.87499686],
       [-0.45640651,  1.0262651 ,  1.08821325]])


>>> arr = np.random.randn(3,3)
>>> arr
array([[ 1.42633942, -0.48664113,  0.02979959],
       [ 0.62360729,  0.57903973,  1.68476841],
       [ 0.94767599, -0.15832117,  0.97161712]])
>>> np.sort(arr)	# np.sort是已排序数组的副本
array([[-0.48664113,  0.02979959,  1.42633942],
       [ 0.57903973,  0.62360729,  1.68476841],
       [-0.15832117,  0.94767599,  0.97161712]])
>>> arr
array([[ 1.42633942, -0.48664113,  0.02979959],
       [ 0.62360729,  0.57903973,  1.68476841],
       [ 0.94767599, -0.15832117,  0.97161712]])

>>> large_arr = np.random.randn(1000)	# 计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值
>>> large_arr.sort()
>>> large_arr[int(0.05*len(large_arr))]
-1.5109867022543568


唯一化以及其他的集合逻辑
>>> import numpy as np
>>> names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
>>> names
array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
      dtype='|S4')
>>> np.unique(names)	# 找出数组中的唯一值并返回已排序的结果
array(['Bob', 'Joe', 'Will'],
      dtype='|S4')

>>> ints = np.array([3, 3, 3, 2, 2, 1, 1, 4, 4])
>>> np.unique(ints)
array([1, 2, 3, 4])


>>> values = np.array([6, 0, 0, 3, 2, 5, 6])	# 另一个函数np.in1d用于测试一个数组中的
>>> np.in1d(values, [2, 3, 6])			# 值在另一个数组中的成员资格，返回一个布尔型数组
array([ True, False, False,  True,  True, False,  True], dtype=bool)


线性代数

>>> import numpy as np
>>> x = np.array([[1, 2, 3], [4, 5, 6]])
>>> y = np.array([[6, 23], [-1, 7], [8, 9]])
>>> x
array([[1, 2, 3],
       [4, 5, 6]])
>>> y
array([[ 6, 23],
       [-1,  7],
       [ 8,  9]])
>>> np.dot(x, y)
array([[ 28,  64],
       [ 67, 181]])


>>> z = np.ones(3)
>>> z
array([ 1.,  1.,  1.])
>>> x
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.dot(x, z)
array([  6.,  15.])


>>> from numpy.linalg import inv, qr
>>> X = np.array([[2,3],[4,5]])
>>> X
array([[2, 3],
       [4, 5]])
>>> M = X.T	# 求X的转置矩阵
>>> M
array([[2, 4],	
       [3, 5]])
>>> X.T.dot(X)	# 先求X的转置矩阵然后与X点乘，XT*X
array([[20, 26],
       [26, 34]])

>>> X
array([[2, 3],
       [4, 5]])
>>> inv(X)	# inv求X的逆矩阵
array([[-2.5,  1.5],
       [ 2. , -1. ]])
>>> inv(X).dot(X)	# 互逆矩阵乘积为I
array([[ 1.,  0.],
       [ 0.,  1.]])


随机数生成
>>> nsteps = 1000
>>> draws = np.random.randint(0, 2, size=nsteps)	# 随机生成100
>>> steps = np.where(draws > 0, 1, -1)
>>> walk = steps.cumsum()
>>> walk.min()
-24
>>> walk.max()
19




###################################
############pandas入门#############
###################################


>>> from pandas import Series, DataFrame
>>> import pandas as pd
>>> obj = Series([4, 7, -5, 3])
>>> obj
0    4
1    7
2   -5
3    3
dtype: int64

>>> obj.values
array([ 4,  7, -5,  3])
>>> obj.index
RangeIndex(start=0, stop=4, step=1)
>>>
>>> obj2 = Series([4, 7, -5, 3], index = ['d', 'b', 'a', 'c'])
>>> obj2
d    4
b    7
a   -5
c    3
dtype: int64
>>> obj2['a']
-5
>>> obj2.index
Index([u'd', u'b', u'a', u'c'], dtype='object')

与普通NumPy数组相比，你可以通过索引的方式选取Series中的单个或一组值：
>>> from pandas import Series, DataFrame
>>> import pandas as pd
>>> obj2 = Series([4, 7, -5, 3], index=['d', 'b', 'a', 'c'])
>>> obj2['a']
-5
>>> obj2['d'] = 10
>>> obj2
d    10
b     7
a    -5
c     3
dtype: int64
>>> obj2[['c', 'a', 'd']]
c     3
a    -5
d    10
dtype: int64


NumPy数组运算（如根据布尔型数组进行过滤、标量乘法、应用数学函数等）都会保留索引和
值之间的链接
>>> obj2
d    10
b     7
a    -5
c     3
dtype: int64
>>> obj2[obj2 > 0]
d    10
b     7
c     3
dtype: int64

>>> obj2*2
d    20
b    14
a   -10
c     6

>>> import numpy as np
>>> np.exp(obj2)
d    22026.465795
b     1096.633158
a        0.006738
c       20.085537


将Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。
它可以用在许多原本需要字典参数的函数中
>>> 'b' in obj2
True
>>> 'e' in obj2
False

如果数据被放在一个Python字典中，也可以直接通过这个字典来创建Series：
>>> sdata = {'Ohio': 35000, 'Texas': 71000, 'Oregon' : 16000,
>>> obj3 = Series(sdata)
>>> obj3
Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64

sdata中跟states索引相匹配的那3个值会被找出来并放到相应
的位置上，但由于"California"所对应的sdata值找不到，所以其结果为NaN
>>> states = ['California', 'Ohio', 'Oregon', 'Texas']
>>> obj4 = Series(sdata, index = states)
>>> obj4
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64


pandas的isnull和notnull函数可用于检测缺失数据：
>>> pd.isnull(obj4)
California     True
Ohio          False
Oregon        False
Texas         False
dtype: bool
>>> pd.notnull(obj4)
California    False
Ohio           True
Oregon         True
Texas          True
dtype: bool


Series最重要的一个功能是：它在算术运算中会自动
对齐不同索引的数据
>>> obj3
Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64
>>> obj4
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64
>>> obj3 + obj4
California         NaN
Ohio           70000.0
Oregon         32000.0
Texas         142000.0
Utah               NaN
dtype: float64


Series对象本身及其索引都有一个name属性，该属性跟pandas其他的
功能非常密切：
>>> obj4.name = 'population'
>>> obj4.index.name = 'state'
>>> obj4
state
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
Name: population, dtype: float64


Series的索引可以通过赋值的方式就地修改：
>>> obj = Series([4, 7, -5, 3])
>>> obj
0    4
1    7
2   -5
3    3
dtype: int64
>>> obj
0    4
1    7
2   -5
3    3
dtype: int64
>>> obj.index=['Bob', 'Steve', 'Jeff', 'Ryan']
>>> obj
Bob      4
Steve    7
Jeff    -5
Ryan     3
dtype: int64


DataFrame表格型数据结构
>>> data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'],
... 'year': [2000, 2001, 2002, 2001, 2002],
... 'pop': [1.5, 1.7, 3.6, 2.4, 2.9]}
>>> frame = DataFrame(data)
>>> frame
   pop   state  year
0  1.5    Ohio  2000
1  1.7    Ohio  2001
2  3.6    Ohio  2002
3  2.4  Nevada  2001
4  2.9  Nevada  2002


如果指定了列序列，则DataFrame的列就会按照指定顺序进行排序
>>> DataFrame(data, columns = ['year', 'state', 'pop'])
   year   state  pop
0  2000    Ohio  1.5
1  2001    Ohio  1.7
2  2002    Ohio  3.6
3  2001  Nevada  2.4
4  2002  Nevada  2.9

跟Series一样，如果传入的列在数据中找不到，就会产生NA值：
>>> frame2 = DataFrame(data, columns=['year', 'state', 'pop', 'debt'],
... index = ['one', 'two', 'three', 'four', 'five'])
>>> frame2
       year   state  pop debt
one    2000    Ohio  1.5  NaN
two    2001    Ohio  1.7  NaN
three  2002    Ohio  3.6  NaN
four   2001  Nevada  2.4  NaN
five   2002  Nevada  2.9  NaN



通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series：
>>> frame2['state']
one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
Name: state, dtype: object
>>> frame['year']
0    2000
1    2001
2    2002
3    2001
4    2002
Name: year, dtype: int64

行也可以通过位置或名称的方式进行获取，比如用索引字段ix
>>> frame2.ix['three']
year     2002
state    Ohio
pop       3.6
debt      NaN

列可以通过赋值的方式进行修改。
>>> frame2['debt'] = np.arange(5.)
>>> frame2
       year   state  pop  debt
one    2000    Ohio  1.5   0.0
two    2001    Ohio  1.7   1.0
three  2002    Ohio  3.6   2.0
four   2001  Nevada  2.4   3.0
five   2002  Nevada  2.9   4.0


将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。
>>> val = Series([-1.2, -1.5, -1.7], index=['two', 'four', 'five'])
>>> frame2['debt'] = val
>>> frame2
       year   state  pop  debt
one    2000    Ohio  1.5   NaN
two    2001    Ohio  1.7  -1.2
three  2002    Ohio  3.6   NaN
four   2001  Nevada  2.4  -1.5
five   2002  Nevada  2.9  -1.7


为不存在的列赋值会创建出一个新列。关键字del用于删除列：
>>> frame2['eastern'] = frame2.state == 'Ohio'
>>> frame2
       year   state  pop  debt eastern
one    2000    Ohio  1.5   NaN    True
two    2001    Ohio  1.7  -1.2    True
three  2002    Ohio  3.6   NaN    True
four   2001  Nevada  2.4  -1.5   False
five   2002  Nevada  2.9  -1.7   False


另一种常见的数据形式是嵌套字典（也就是字典的字典）
>>> pop = {'Nevada': {2001: 2.4, 2002: 2.9},
... 'Ohio':{2000: 1.5, 2001: 1.7, 2002: 3.6}}
>>> frame3 = DataFrame(pop)
>>> frame3
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7
2002     2.9   3.6














