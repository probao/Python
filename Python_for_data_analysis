###################################
###numpy基础：数组和矢量的计算#####
###################################


创建ndarray
>>> import numpy as np
>>> data1 = [6, 7.5, 8, 0, 1]
>>> arr1 = np.array(data1)	# 使用array函数，它接受一切序列型的对象，产生一个含有传入数据的numpy数组
>>> arr1
array([ 6. ,  7.5,  8. ,  0. ,  1. ])


嵌套序列
>>> data2 = [[1,2,3,4], [5, 6, 7, 8]]
>>> arr2 = np.array(data2)
>>> arr2
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])
>>> arr2.ndim	# 数组的维数
2
>>> arr2.shape	# 2行4列的数组
(2, 4)

>>> arr1.dtype	# 数据类型保存在一个特殊的dtype对象中
dtype('float64')
>>> arr2.dtype
dtype('int32')


其它函数新建数组
>>> np.zeros(10)	# 生成全是0的数组
array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
>>> np.zeros((3, 6))
array([[ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.]])
>>> np.ones((3, 6))	# 生成全是1的数组
array([[ 1.,  1.,  1.,  1.,  1.,  1.],
       [ 1.,  1.,  1.,  1.,  1.,  1.],
       [ 1.,  1.,  1.,  1.,  1.,  1.]])
>>> np.empty((2, 3, 2))		# 生成的不是0， 是一些未被处理的垃圾值
array([[[  1.03510883e-295,   6.38742701e-314],
        [  1.55420853e-285,   1.27319747e-313],
        [  1.27319747e-313,   1.27319747e-313]],

       [[  2.37332014e-286,   1.91205622e-313],
        [  8.13462439e-296,   2.75859453e-313],
        [  2.48324480e-286,   3.12237178e-120]]])

>>> np.arange(15)		# arange是python内置函数range的数组版
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])

>>> np.eye(3)			# 对角线是1的数组
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])


ndarray的数据类型
>>> arr1 = np.array([1, 2, 3], dtype=np.float64)
>>> arr2 = np.array([1, 2, 3], dtype=np.int32)
>>> arr1.dtype
dtype('float64')
>>> arr2.dtype
dtype('int32')



数组和标量之间的运算
>>> arr = np.array([[1., 2., 3.], [4., 5., 6.]])
>>> arr
array([[ 1.,  2.,  3.],
       [ 4.,  5.,  6.]])
>>> arr*arr
array([[  1.,   4.,   9.],	#大小相等的数组的任何运算都会将运算运用到元素级
       [ 16.,  25.,  36.]])
>>> 1/arr
array([[ 1.        ,  0.5       ,  0.33333333],
       [ 0.25      ,  0.2       ,  0.16666667]])
>>> arr**0.5
array([[ 1.        ,  1.41421356,  1.73205081],
       [ 2.        ,  2.23606798,  2.44948974]])

>>> a = np.array([[1,2],[1,2]])	#矩阵的运算需要dot函数
>>> np.dot(a,a)
array([[3, 6],
       [3, 6]])


基本的索引和切片
>>> import numpy as np
>>> arr = np.arange(10)
>>> arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>>
>>>
>>> arr[5]
5
>>>
>>> arr[5:8]
array([5, 6, 7])
>>> arr[5:8] = 12
>>> arr
array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9]) # 当一个标量值赋值给一个切片时，该值会自动传播到整个选取


>>> arr_slice = arr[5:8]
>>> arr_slice[1] = 12345
>>> arr
array([    0,     1,     2,     3,     4,    12, 12345,    12,     8,     9])
>>> arr_slice[:] = 64
>>> arr
array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])


>>> arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])	# 多维数组索引
>>> arr2d[2]
array([7, 8, 9])
>>> arr2d[0][2]
3
>>> arr2d[0, 2]
3


>>> arr3d = np.array([[[1, 2, 3], [4, 5, 6]],[[7, 8, 9], [10, 11, 12]]])
>>> arr3d	# 括号外面的“维度”是一维，二维，。。。而括号里面的应该理解为“轴”--类比三维数组
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
>>> arr3d [0]
array([[1, 2, 3],
       [4, 5, 6]])



>>> old_values = arr3d[0].copy()
>>>
>>> arr3d[0] = 42
>>> arr3d
array([[[42, 42, 42],
        [42, 42, 42]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
>>> arr3d[0] = old_values	# 标量和数组都可以被赋值给arr3d[0]
>>> arr3d
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

>>> arr3d[1, 0]
array([7, 8, 9])

切片索引

>>> arr
array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])
>>> arr[1:6]
array([ 1,  2,  3,  4, 64])


>>> arr2d
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
>>> arr2d[:2]	#[:2]意思是--第0项和第1项
array([[1, 2, 3],
       [4, 5, 6]])
>>> arr2d[:2, 1:]	# [1:] 第一项到最后
array([[2, 3],
       [5, 6]])


>>> arr2d[1, :2]
array([4, 5])
>>> arr2d[2, :1]
array([7])
>>> arr2d[:, :1]	
array([[1],
       [4],
       [7]])
>>> arr2d[:2, 1:]
array([[2, 3],
       [5, 6]])
>>> arr2d[:2, 1:] = 0	#对切片表达式的赋值操作也会被扩赛到整个选区
>>> arr2d
array([[1, 0, 0],
       [4, 0, 0],
       [7, 8, 9]])


布尔型索引

>>> data = np.random.randn(7, 4)
>>> data
array([[-0.31042535, -2.17572506,  0.56252532,  0.99534791],
       [ 0.63397486, -0.13189191,  0.29471484,  0.50351773],
       [ 0.51495017,  0.04994144, -0.1762269 , -0.19449053],
       [-0.07743183, -0.42964157, -1.39686796, -1.11814711],
       [-1.13909174, -0.65366514, -0.2169853 ,  0.61072596],
       [ 1.41913738, -1.2421399 ,  0.45052187, -0.17214591],
       [-0.14628746,  0.25535978, -1.04384285,  0.45418343]])
>>> names
array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
      dtype='|S4')
>>> names == 'Bob'
array([ True, False, False,  True, False, False, False], dtype=bool)
>>> data[names ==  'Bob']	# 布尔型数组可用于数组索引，布尔型数组的长度必须跟被索引的轴长度一致
array([[-0.31042535, -2.17572506,  0.56252532,  0.99534791],
       [-0.07743183, -0.42964157, -1.39686796, -1.11814711]])


>>> data[names ==  'Bob', 2:]	# 布尔型数组跟切片混合使用
array([[ 0.56252532,  0.99534791],
       [-1.39686796, -1.11814711]])

>>> data[names ==  'Bob', 3]
array([ 0.99534791, -1.11814711])

>>> names != 'Bob'	# 选择除“Bob”以外的其他值可以使用不等于符号(!=),也可以通过负号
array([False,  True,  True, False,  True,  True,  True], dtype=bool)
>>> data[-(names ==  'Bob')]
array([[ 0.63397486, -0.13189191,  0.29471484,  0.50351773],
       [ 0.51495017,  0.04994144, -0.1762269 , -0.19449053],
       [-1.13909174, -0.65366514, -0.2169853 ,  0.61072596],
       [ 1.41913738, -1.2421399 ,  0.45052187, -0.17214591],
       [-0.14628746,  0.25535978, -1.04384285,  0.45418343]])


>>> mask = (names == 'Bob')|(names == 'Will')
>>> mask
array([ True, False,  True,  True,  True, False, False], dtype=bool)
>>> mask1 = (names == 'Bob') & (names == 'Will')
>>> mask1
array([False, False, False, False, False, False, False], dtype=bool)
>>> data[mask]
array([[-0.31042535, -2.17572506,  0.56252532,  0.99534791],
       [ 0.51495017,  0.04994144, -0.1762269 , -0.19449053],
       [-0.07743183, -0.42964157, -1.39686796, -1.11814711],
       [-1.13909174, -0.65366514, -0.2169853 ,  0.61072596]])


>>> data
array([[-0.31042535, -2.17572506,  0.56252532,  0.99534791],
       [ 0.63397486, -0.13189191,  0.29471484,  0.50351773],
       [ 0.51495017,  0.04994144, -0.1762269 , -0.19449053],
       [-0.07743183, -0.42964157, -1.39686796, -1.11814711],
       [-1.13909174, -0.65366514, -0.2169853 ,  0.61072596],
       [ 1.41913738, -1.2421399 ,  0.45052187, -0.17214591],
       [-0.14628746,  0.25535978, -1.04384285,  0.45418343]])
>>>
>>> data[data < 0] = 0	#将data中的所有负值都设置为0
>>> data
array([[ 0.        ,  0.        ,  0.56252532,  0.99534791],
       [ 0.63397486,  0.        ,  0.29471484,  0.50351773],
       [ 0.51495017,  0.04994144,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.61072596],
       [ 1.41913738,  0.        ,  0.45052187,  0.        ],
       [ 0.        ,  0.25535978,  0.        ,  0.45418343]])

>>> data[names != 'Joe'] = 7	#
>>> data
array([[ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 0.63397486,  0.        ,  0.29471484,  0.50351773],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 1.41913738,  0.        ,  0.45052187,  0.        ],
       [ 0.        ,  0.25535978,  0.        ,  0.45418343]])


花式索引
>>> arr = np.empty((8,4))
>>> for i in range(8):
...     arr[i] = i
...
>>> arr
array([[ 0.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  1.],
       [ 2.,  2.,  2.,  2.],
       [ 3.,  3.,  3.,  3.],
       [ 4.,  4.,  4.,  4.],
       [ 5.,  5.,  5.,  5.],
       [ 6.,  6.,  6.,  6.],
       [ 7.,  7.,  7.,  7.]])
>>> arr[[4, 3, 0, 6]]	# 第四行，第三行，第零行 和 第六行
array([[ 4.,  4.,  4.,  4.],
       [ 3.,  3.,  3.,  3.],
       [ 0.,  0.,  0.,  0.],
       [ 6.,  6.,  6.,  6.]])

>>> arr[[-3, -5, 0, -7]]	#使用负数索引将会从末尾开始选取行
array([[ 5.,  5.,  5.,  5.],
       [ 3.,  3.,  3.,  3.],
       [ 0.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  1.]])


>>> arr = np.arange(32).reshape((8, 4)) # 一次传入多个索引数组，它返回的是一个一维数组，其中的元素对应各个索引元组
>>> arr
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])
>>> arr[[1, 5, 7, 2],[0, 3, 1, 2]]
array([ 4, 23, 29, 10])

>>> arr[[1, 5, 7, 2]][:,[0, 3, 1, 2]]	# 先取行，再取列
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])



数组转置和轴对换
>>> arr = np.arange(15).reshape((3, 5))
>>> arr
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
>>> arr.T
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])



>>> arr = np.arange(16).reshape((2, 2, 4))
>>> arr
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
>>> arr.transpose((1, 0, 2))
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])
>>> arr.transpose((1, 2, 0))
array([[[ 0,  8],
        [ 1,  9],
        [ 2, 10],
        [ 3, 11]],

       [[ 4, 12],
        [ 5, 13],
        [ 6, 14],
        [ 7, 15]]])

我说你来试一下哈：
arr1.shape 应该是(2, 2, 4) 意为 2维，2*4矩阵

arr1.transpose(*args) 里面的参数，可以这么理解，他是调换arr1.shape的顺序，咱来给arr1.shape标一下角标哈，（2[0], 2[1], 4[2]）  [ ] 里是shape的索引，对吧， 
transpose((1, 0, 2)) 的意思是 按照这个顺序 重新设置shape 也就是 （2[1], 2[0], 4[2]）

 虽然看起来 变换前后的shape都是 2,2,4  ， 但是问题来了，transpose是转置
shape按照(1,0,2)的顺序重新设置了， array里的所有元素 也要按照这个规则重新组成新矩阵

 比如 8 在arr1中的索引是 (1, 0, 0)  那么按照刚才的变换规则，就是 (0, 1, 0) 看看跟你结果arr2的位置一样了吧，依此类推...



通用函数:快速的元素级数组函数
>>> import numpy as np
>>> arr = np.arange(10)
>>> np.sqrt(arr)
array([ 0.        ,  1.        ,  1.41421356,  1.73205081,  2.        ,
        2.23606798,  2.44948974,  2.64575131,  2.82842712,  3.        ])
>>> np.exp(arr)
array([  1.00000000e+00,   2.71828183e+00,   7.38905610e+00,
         2.00855369e+01,   5.45981500e+01,   1.48413159e+02,
         4.03428793e+02,   1.09663316e+03,   2.98095799e+03,
         8.10308393e+03])
sqrt和exp是一元（unary）ufunc，另外一些（如add或maximum）接受2个数组，也叫二元数组

>>> x = np.random.randn(8)
>>> y = np.random.randn(8)
>>> x
array([-1.09442604, -1.43680231, -0.28154207,  0.84074478, -0.18878751,
        0.50501874,  0.28835676,  1.85865484])
>>> y
array([ 0.97924522, -0.94704341,  0.04190887,  1.60123804,  0.12770678,
        0.04152567, -0.11783759, -0.75930132])
>>> np.maximum(x, y)
array([ 0.97924522, -0.94704341,  0.04190887,  1.60123804,  0.12770678,
        0.50501874,  0.28835676,  1.85865484])

>>> arr = np.random.randn(7)*5
>>> arr
array([ -9.17367478,   0.71396009, -10.1828497 ,   0.45724798,
        -1.05427677,   3.08732191,  -0.73990597])
>>> np.modf(arr)	# 返回两个数组 一个是小数部分，一个是整数部分
(array([-0.17367478,  0.71396009, -0.1828497 ,  0.45724798, -0.05427677,
        0.08732191, -0.73990597]), array([ -9.,   0., -10.,   0.,  -1.,   3.,  -0.]))



利用数组进行数据处理
>>> points = np.arange(-5, 5, 0.01)
>>> xs, ys = np.meshgrid(points, points)	#生成网格，两个二维数组
>>> ys
array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
       ...,
       [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])
>>> xs
array([[-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       ...,
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99]])
>>> import matplotlib.pyplot as plt
>>> z = np.sqrt(xs**2 + ys**2)
>>> z
array([[ 7.07106781,  7.06400028,  7.05693985, ...,  7.04988652,
         7.05693985,  7.06400028],
       [ 7.06400028,  7.05692568,  7.04985815, ...,  7.04279774,
         7.04985815,  7.05692568],
       [ 7.05693985,  7.04985815,  7.04278354, ...,  7.03571603,
         7.04278354,  7.04985815],
       ...,
       [ 7.04988652,  7.04279774,  7.03571603, ...,  7.0286414 ,
         7.03571603,  7.04279774],
       [ 7.05693985,  7.04985815,  7.04278354, ...,  7.03571603,
         7.04278354,  7.04985815],
       [ 7.06400028,  7.05692568,  7.04985815, ...,  7.04279774,
         7.04985815,  7.05692568]])
>>> plt.imshow(z, cmap=plt.cm.gray);plt.colorbar()
<matplotlib.image.AxesImage object at 0x062666B0>
<matplotlib.colorbar.Colorbar object at 0x062BE0D0>
>>> plt.show()


将条件逻辑表述为数组运算
假设我们要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值
否则从yarr中选取
>>> import numpy as np
>>> xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
>>> yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
>>> cond = np.array([True, False, True, True, False])
>>> result = np.where(cond, xarr, yarr)
>>> result
array([ 1.1,  2.2,  1.3,  1.4,  2.5])

np.where的第二个和第三个参数不必是数组，它们都是可以是标量值。在数据分析工作中
，where通常用于根据另一个数组而产生一个新的数组。


>>> arr = np.random.randn(4,4)
>>> arr
array([[-0.32285005,  0.25847681,  0.66953569,  1.7002404 ],
       [ 0.22827269,  1.02391622, -0.8919314 ,  0.38018606],
       [ 0.3845627 ,  0.84781941, -0.28423424,  1.73434853],
       [-0.76948816,  0.36355368,  1.56517939,  0.00546952]])
>>> np.where(arr > 0, 2, -2)	# 将数组中大于零的换成2，小于零的换成-2
array([[-2,  2,  2,  2],
       [ 2,  2, -2,  2],
       [ 2,  2, -2,  2],
       [-2,  2,  2,  2]])
>>> np.where(arr > 0, 2, arr)	# 只将数组中大于零的换成2
array([[-0.32285005,  2.        ,  2.        ,  2.        ],
       [ 2.        ,  2.        , -0.8919314 ,  2.        ],
       [ 2.        ,  2.        , -0.28423424,  2.        ],
       [-0.76948816,  2.        ,  2.        ,  2.        ]])



数学和统计方法
>>> arr = np.random.randn(5,4)
>>> arr
array([[-1.71504642,  0.22678685,  0.74513757,  1.70279446],
       [-0.34902157,  0.27176852, -1.52373216, -0.24647356],
       [-0.49901881, -0.11396496, -0.00902927, -0.30132351],
       [-0.44314036, -0.10644648, -1.3300278 , -3.00895452],
       [-0.26927576, -0.61164494, -1.39029488, -0.08084923]])
>>> arr.mean()		# 数组的平均数
-0.45258784121946649
>>> np.mean(arr)	# 数组的平均数
-0.45258784121946649
>>> arr.sum()
-9.0517568243893294	# 数组的和
>>> arr
array([[-1.71504642,  0.22678685,  0.74513757,  1.70279446],
       [-0.34902157,  0.27176852, -1.52373216, -0.24647356],
       [-0.49901881, -0.11396496, -0.00902927, -0.30132351],
       [-0.44314036, -0.10644648, -1.3300278 , -3.00895452],
       [-0.26927576, -0.61164494, -1.39029488, -0.08084923]])
>>> arr.mean(axis = 1)		# 每一行的平均数
array([ 0.23991811, -0.46186469, -0.23083414, -1.22214229, -0.5880162 ])
>>> arr.mean(axis = 0)		# 每一列的平均数
array([-0.65510058, -0.0667002 , -0.70158931, -0.38696127])


>>> arr = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
>>> arr.cumsum(0)	# 沿列的方向 每一行加下一行
array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]])
>>> arr.cumsum(1)	# 沿行的方向 每一列加下一列
array([[ 0,  1,  3],
       [ 3,  7, 12],
       [ 6, 13, 21]])
>>> arr.cumprod(1)
array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]])
>>> arr.cumprod(0)
array([[ 0,  1,  2],
       [ 0,  4, 10],
       [ 0, 28, 80]])


用于布尔型数组的方法
>>> import numpy as np
>>> arr = np.random.randn(100)
>>> (arr > 0).sum()	# sum经常被用来对布尔型数组
58

>>> bools = np.array([False, False, True, False])
>>> bools.any()	# 用于测试有一个或多个True
True
>>> bools.all()	# 用于测试数组中是否全是True
False
这两个方法也能用于非布尔型数组，所有非0元素会被当做True


排序
>>> arr = np.random.randn(8)
>>> arr
array([-1.50790127, -1.22640436, -0.00729792, -0.42537421, -0.93833854,
       -0.6814844 ,  1.32235945, -0.09862056])
>>> arr.sort()
>>> arr
array([-1.50790127, -1.22640436, -0.93833854, -0.6814844 , -0.42537421,
       -0.09862056, -0.00729792,  1.32235945])


>>> arr = np.random.randn(3,3)
>>> arr
array([[-1.61589688, -0.65173118,  0.14666864],
       [ 0.87499686,  0.50801178, -0.06954368],
       [ 1.0262651 ,  1.08821325, -0.45640651]])
>>> arr.sort(1)		# 水平轴向sort
>>> arr
array([[-1.61589688, -0.65173118,  0.14666864],
       [-0.06954368,  0.50801178,  0.87499686],
       [-0.45640651,  1.0262651 ,  1.08821325]])


>>> arr = np.random.randn(3,3)
>>> arr
array([[ 1.42633942, -0.48664113,  0.02979959],
       [ 0.62360729,  0.57903973,  1.68476841],
       [ 0.94767599, -0.15832117,  0.97161712]])
>>> np.sort(arr)	# np.sort是已排序数组的副本
array([[-0.48664113,  0.02979959,  1.42633942],
       [ 0.57903973,  0.62360729,  1.68476841],
       [-0.15832117,  0.94767599,  0.97161712]])
>>> arr
array([[ 1.42633942, -0.48664113,  0.02979959],
       [ 0.62360729,  0.57903973,  1.68476841],
       [ 0.94767599, -0.15832117,  0.97161712]])

>>> large_arr = np.random.randn(1000)	# 计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值
>>> large_arr.sort()
>>> large_arr[int(0.05*len(large_arr))]
-1.5109867022543568


唯一化以及其他的集合逻辑
>>> import numpy as np
>>> names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
>>> names
array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
      dtype='|S4')
>>> np.unique(names)	# 找出数组中的唯一值并返回已排序的结果
array(['Bob', 'Joe', 'Will'],
      dtype='|S4')

>>> ints = np.array([3, 3, 3, 2, 2, 1, 1, 4, 4])
>>> np.unique(ints)
array([1, 2, 3, 4])


>>> values = np.array([6, 0, 0, 3, 2, 5, 6])	# 另一个函数np.in1d用于测试一个数组中的
>>> np.in1d(values, [2, 3, 6])			# 值在另一个数组中的成员资格，返回一个布尔型数组
array([ True, False, False,  True,  True, False,  True], dtype=bool)


线性代数

>>> import numpy as np
>>> x = np.array([[1, 2, 3], [4, 5, 6]])
>>> y = np.array([[6, 23], [-1, 7], [8, 9]])
>>> x
array([[1, 2, 3],
       [4, 5, 6]])
>>> y
array([[ 6, 23],
       [-1,  7],
       [ 8,  9]])
>>> np.dot(x, y)
array([[ 28,  64],
       [ 67, 181]])


>>> z = np.ones(3)
>>> z
array([ 1.,  1.,  1.])
>>> x
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.dot(x, z)
array([  6.,  15.])


>>> from numpy.linalg import inv, qr
>>> X = np.array([[2,3],[4,5]])
>>> X
array([[2, 3],
       [4, 5]])
>>> M = X.T	# 求X的转置矩阵
>>> M
array([[2, 4],	
       [3, 5]])
>>> X.T.dot(X)	# 先求X的转置矩阵然后与X点乘，XT*X
array([[20, 26],
       [26, 34]])

>>> X
array([[2, 3],
       [4, 5]])
>>> inv(X)	# inv求X的逆矩阵
array([[-2.5,  1.5],
       [ 2. , -1. ]])
>>> inv(X).dot(X)	# 互逆矩阵乘积为I
array([[ 1.,  0.],
       [ 0.,  1.]])


随机数生成
>>> nsteps = 1000
>>> draws = np.random.randint(0, 2, size=nsteps)	# 随机生成100
>>> steps = np.where(draws > 0, 1, -1)
>>> walk = steps.cumsum()
>>> walk.min()
-24
>>> walk.max()
19




###################################
############pandas入门#############
###################################


>>> from pandas import Series, DataFrame
>>> import pandas as pd
>>> obj = Series([4, 7, -5, 3])
>>> obj
0    4
1    7
2   -5
3    3
dtype: int64

>>> obj.values
array([ 4,  7, -5,  3])
>>> obj.index
RangeIndex(start=0, stop=4, step=1)
>>>
>>> obj2 = Series([4, 7, -5, 3], index = ['d', 'b', 'a', 'c'])
>>> obj2
d    4
b    7
a   -5
c    3
dtype: int64
>>> obj2['a']
-5
>>> obj2.index
Index([u'd', u'b', u'a', u'c'], dtype='object')

与普通NumPy数组相比，你可以通过索引的方式选取Series中的单个或一组值：
>>> from pandas import Series, DataFrame
>>> import pandas as pd
>>> obj2 = Series([4, 7, -5, 3], index=['d', 'b', 'a', 'c'])
>>> obj2['a']
-5
>>> obj2['d'] = 10
>>> obj2
d    10
b     7
a    -5
c     3
dtype: int64
>>> obj2[['c', 'a', 'd']]
c     3
a    -5
d    10
dtype: int64


NumPy数组运算（如根据布尔型数组进行过滤、标量乘法、应用数学函数等）都会保留索引和
值之间的链接
>>> obj2
d    10
b     7
a    -5
c     3
dtype: int64
>>> obj2[obj2 > 0]
d    10
b     7
c     3
dtype: int64

>>> obj2*2
d    20
b    14
a   -10
c     6

>>> import numpy as np
>>> np.exp(obj2)
d    22026.465795
b     1096.633158
a        0.006738
c       20.085537


将Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。
它可以用在许多原本需要字典参数的函数中
>>> 'b' in obj2
True
>>> 'e' in obj2
False

如果数据被放在一个Python字典中，也可以直接通过这个字典来创建Series：
>>> sdata = {'Ohio': 35000, 'Texas': 71000, 'Oregon' : 16000,
>>> obj3 = Series(sdata)
>>> obj3
Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64

sdata中跟states索引相匹配的那3个值会被找出来并放到相应
的位置上，但由于"California"所对应的sdata值找不到，所以其结果为NaN
>>> states = ['California', 'Ohio', 'Oregon', 'Texas']
>>> obj4 = Series(sdata, index = states)
>>> obj4
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64


pandas的isnull和notnull函数可用于检测缺失数据：
>>> pd.isnull(obj4)
California     True
Ohio          False
Oregon        False
Texas         False
dtype: bool
>>> pd.notnull(obj4)
California    False
Ohio           True
Oregon         True
Texas          True
dtype: bool


Series最重要的一个功能是：它在算术运算中会自动
对齐不同索引的数据
>>> obj3
Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64
>>> obj4
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64
>>> obj3 + obj4
California         NaN
Ohio           70000.0
Oregon         32000.0
Texas         142000.0
Utah               NaN
dtype: float64


Series对象本身及其索引都有一个name属性，该属性跟pandas其他的
功能非常密切：
>>> obj4.name = 'population'
>>> obj4.index.name = 'state'
>>> obj4
state
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
Name: population, dtype: float64


Series的索引可以通过赋值的方式就地修改：
>>> obj = Series([4, 7, -5, 3])
>>> obj
0    4
1    7
2   -5
3    3
dtype: int64
>>> obj
0    4
1    7
2   -5
3    3
dtype: int64
>>> obj.index=['Bob', 'Steve', 'Jeff', 'Ryan']
>>> obj
Bob      4
Steve    7
Jeff    -5
Ryan     3
dtype: int64


DataFrame表格型数据结构
>>> data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'],
... 'year': [2000, 2001, 2002, 2001, 2002],
... 'pop': [1.5, 1.7, 3.6, 2.4, 2.9]}
>>> frame = DataFrame(data)
>>> frame
   pop   state  year
0  1.5    Ohio  2000
1  1.7    Ohio  2001
2  3.6    Ohio  2002
3  2.4  Nevada  2001
4  2.9  Nevada  2002


如果指定了列序列，则DataFrame的列就会按照指定顺序进行排序
>>> DataFrame(data, columns = ['year', 'state', 'pop'])
   year   state  pop
0  2000    Ohio  1.5
1  2001    Ohio  1.7
2  2002    Ohio  3.6
3  2001  Nevada  2.4
4  2002  Nevada  2.9

跟Series一样，如果传入的列在数据中找不到，就会产生NA值：
>>> frame2 = DataFrame(data, columns=['year', 'state', 'pop', 'debt'],
... index = ['one', 'two', 'three', 'four', 'five'])
>>> frame2
       year   state  pop debt
one    2000    Ohio  1.5  NaN
two    2001    Ohio  1.7  NaN
three  2002    Ohio  3.6  NaN
four   2001  Nevada  2.4  NaN
five   2002  Nevada  2.9  NaN



通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series：
>>> frame2['state']
one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
Name: state, dtype: object
>>> frame['year']
0    2000
1    2001
2    2002
3    2001
4    2002
Name: year, dtype: int64

行也可以通过位置或名称的方式进行获取，比如用索引字段ix
>>> frame2.ix['three']
year     2002
state    Ohio
pop       3.6
debt      NaN

>>> frame2
       year   state  pop debt
one       1    Ohio  1.5  NaN
two    2001    Ohio  1.7  NaN
three  2002    Ohio  3.6  NaN
four   2001  Nevada  2.4  NaN
five   2002  Nevada  2.9  NaN
>>> frame2['debt']['one']=2
>>> frame2
       year   state  pop debt
one       1    Ohio  1.5    2
two    2001    Ohio  1.7  NaN
three  2002    Ohio  3.6  NaN
four   2001  Nevada  2.4  NaN
five   2002  Nevada  2.9  NaN


列可以通过赋值的方式进行修改。
>>> frame2['debt'] = np.arange(5.)
>>> frame2
       year   state  pop  debt
one    2000    Ohio  1.5   0.0
two    2001    Ohio  1.7   1.0
three  2002    Ohio  3.6   2.0
four   2001  Nevada  2.4   3.0
five   2002  Nevada  2.9   4.0


将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。
>>> val = Series([-1.2, -1.5, -1.7], index=['two', 'four', 'five'])
>>> frame2['debt'] = val
>>> frame2
       year   state  pop  debt
one    2000    Ohio  1.5   NaN
two    2001    Ohio  1.7  -1.2
three  2002    Ohio  3.6   NaN
four   2001  Nevada  2.4  -1.5
five   2002  Nevada  2.9  -1.7


为不存在的列赋值会创建出一个新列。关键字del用于删除列：
>>> frame2['eastern'] = frame2.state == 'Ohio'
>>> frame2
       year   state  pop  debt eastern
one    2000    Ohio  1.5   NaN    True
two    2001    Ohio  1.7  -1.2    True
three  2002    Ohio  3.6   NaN    True
four   2001  Nevada  2.4  -1.5   False
five   2002  Nevada  2.9  -1.7   False


另一种常见的数据形式是嵌套字典（也就是字典的字典）
>>> pop = {'Nevada': {2001: 2.4, 2002: 2.9},
... 'Ohio':{2000: 1.5, 2001: 1.7, 2002: 3.6}}
>>> frame3 = DataFrame(pop)
>>> frame3
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7
2002     2.9   3.6

转置
>>> frame3.T
        2000  2001  2002
Nevada   NaN   2.4   2.9
Ohio     1.5   1.7   3.6

由Series组成的字典差不多也是一样的用法：
>>> pdata = {'Ohio':frame3['Ohio'][:-1],
... 'Nevada': frame3['Nevada'][:2]}
>>> DataFrame(pdata)
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7


如果设置了DataFrame的index和columns的name属性，则这些信息也会被显示出来
>>> frame3.index.name = 'year'
>>> frame3.columns.name = 'state'
>>> frame3
state  Nevada  Ohio
year
2000      NaN   1.5
2001      2.4   1.7
2002      2.9   3.6


跟Series一样，values属性也会以二维ndarray的形式返回DataFrame中的数据：
>>> frame3.values
array([[ nan,  1.5],
       [ 2.4,  1.7],
       [ 2.9,  3.6]])
>>> frame2.values
array([[2000, 'Ohio', 1.5, nan, True],
       [2001, 'Ohio', 1.7, -1.2, True],
       [2002, 'Ohio', 3.6, nan, True],
       [2001, 'Nevada', 2.4, -1.5, False],
       [2002, 'Nevada', 2.9, -1.7, False]], dtype=object)



二维ndarry可以输入给DataFrame构造器的数据
>>> xarr = np.array([[1, 2, 3], [2, 4, 6]])
>>> xarr
array([[1, 2, 3],
       [2, 4, 6]])
>>> frame5 = DataFrame(xarr)
>>> frame5
   0  1  2
0  1  2  3
1  2  4  6
>>> frame5 = DataFrame(xarr, columns=['A', 'B','F'], index = ['C', 'D'])
>>> frame5
   A  B  F
C  1  2  3
D  2  4  6

索引对象
>>> obj = Series(range(3), index=['a', 'b', 'c'])
>>> obj
a    0
b    1
c    2
dtype: int64
>>> index = obj.index
>>> index
Index([u'a', u'b', u'c'], dtype='object')
>>> index[1:]
Index([u'b', u'c'], dtype='object')

Index对象是不可修改的
>>> index[1]
'b'
>>> index[1] = 'd'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/opt/linux/centos/7.x/x86_64/pkgs/python/2.7.5/lib64/python2.7/site-packages/pandas/indexes/base.py", line 1237, in __setitem__
    raise TypeError("Index does not support mutable operations")
TypeError: Index does not support mutable operations

不可修改性非常重要，因为这样才能使Index对象在多个数据结构之间安全共享
>>> obj2 = Series([1.5, -2.5, 0], index=index)
>>> obj2
0    1.5
1   -2.5
2    0.0
dtype: float64
>>> obj2.index is index
True


Index的功能也类似一个固定大小的集合
>>> import pandas as pd
>>> from pandas import Series, DataFrame
>>>
>>>
>>> pop = {'Nevada':{2001: 2.4, 2002: 2.9},
... 'Ohio': {2000: 1.5, 2001: 1.7, 2002: 3.6}}
>>> frame3 = DataFrame(pop)
>>> frame3
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7
2002     2.9   3.6

>>> pdata={'Ohio':frame3['Ohio'][:-1],	# 到最后个为止
... 'Nevada':frame3['Nevada'][:2]}	# 输出第0个，第1个
>>> DataFrame(pdata)
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7

>>> 'Ohio' in frame3.columns
True
>>> 2003 in frame3.index
False


索引对象






基本功能
重新索引 reindex
>>> obj = Series([4.5, 7.2, -5.3, 3.6], index=['d', 'b', 'a', 'c'])
>>> obj
d    4.5
b    7.2
a   -5.3
c    3.6
dtype: float64
>>> obj2 = obj.reindex(['a', 'b', 'c', 'd', 'e']) # 调用该Series的reindex将会根据新索引
>>> obj
d    4.5
b    7.2
a   -5.3
c    3.6
dtype: float64
>>> obj2
a   -5.3
b    7.2
c    3.6
d    4.5
e    NaN
dtype: float64

>>> obj2 = obj.reindex(['a', 'b', 'c', 'd', 'e'], fill_value=0)# 用fill_value来填充值
>>> obj2
a   -5.3
b    7.2
c    3.6
d    4.5
e    0.0
dtype: float64


对于时间序列这样的有序数据，需要插值处理
>>> obj3 = Series(['blue', 'purple', 'yellow'], index=[0, 2, 4])	
>>> obj3.reindex(range(6), method = 'ffill')	# method选项 可进行插值处理 ffill 前向插值，和前面的一样
0      blue
1      blue
2    purple
3    purple
4    yellow
5    yellow
dtype: object

>>> obj3.reindex(range(5), method = 'bfill')	# bfill 后向引用 和后面的一样
0      blue
1    purple
2    purple
3    yellow
4    yellow


对于DataFrame，reindex可以修改（行）索引、列，或两个都修改。如果仅转入一个序列，则会重新
索引行：
>>> frame = DataFrame(np.arange(9).reshape((3, 3)), index = ['a', 'c', 'd'], columns = ['Ohio', 'Texas', 'California'])
>>> frame
   Ohio  Texas  California
a     0      1           2
c     3      4           5
d     6      7           8


>>> import numpy as np
>>> frame = DataFrame(np.arange(9).reshape((3, 3)), index = ['a', '               umns = ['Ohio', 'Texas', 'California'])
>>> frame
   Ohio  Texas  California
a     0      1           2
c     3      4           5
d     6      7           8
>>> frame2 = frame.reindex(['a', 'b', 'c', 'd'])
>>> frame2
   Ohio  Texas  California
a   0.0    1.0         2.0
b   NaN    NaN         NaN
c   3.0    4.0         5.0
d   6.0    7.0         8.0
>>> states = ['Texas', 'Utah', 'California']
>>> frame.reindex(columns = states)
   Texas  Utah  California
a      1   NaN           2
c      4   NaN           5
d      7   NaN           8

也可以同时对行和列进行重新索引，而插值则只能按行引用（即轴0）：
>>> frame.reindex(index=['a', 'b', 'c', 'd'], method='ffill', columns=states)
   Texas  Utah  California
a      1   NaN           2
b      1   NaN           2
c      4   NaN           5
d      7   NaN           8


利用ix的标签索引功能，重新索引任务可以变得更简洁：
>>> frame.ix[['a', 'b', 'c', 'd'], states]
   Texas  Utah  California
a    1.0   NaN         2.0
b    NaN   NaN         NaN
c    4.0   NaN         5.0
d    7.0   NaN         8.0


丢弃指定轴上的项
>>> obj = Series(np.arange(5.), index=['a', 'b', 'c', 'd', 'e'])
>>> obj
a    0.0
b    1.0
c    2.0
d    3.0
e    4.0
dtype: float64
>>> new_obj = obj.drop('c')	# drop方法返回的是一个在指定轴上删除了指定值的新对象
>>> new_obj
a    0.0
b    1.0
d    3.0
e    4.0
dtype: float64
>>> obj.drop(['d', 'c'])
a    0.0
b    1.0
e    4.0
dtype: float64


对于DataFrame，可以删除任意轴上的索引值：
>>> data = DataFrame(np.arange(16).reshape((4, 4)),
... index=['Ohio', 'Colorado', 'Utah', 'New York'],
... columns=['one', 'two', 'three', 'four'])
>>>
>>> data
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

>>> data.drop(['Colorado', 'Ohio'])
          one  two  three  four
Utah        8    9     10    11
New York   12   13     14    15

>>> data.drop('two', axis=1)
          one  three  four
Ohio        0      2     3
Colorado    4      6     7
Utah        8     10    11
New York   12     14    15

>>> data.drop(['two', 'four'], axis=1)	
          one  three
Ohio        0      2
Colorado    4      6
Utah        8     10
New York   12     14


索引、选取和过滤
>>> obj=Series(np.arange(4.), index=['a', 'b', 'c', 'd'])
>>> obj
a    0.0
b    1.0
c    2.0
d    3.0
dtype: float64
>>> obj['b']
1.0
>>> obj[1]
1.0
>>> obj[2:4]
c    2.0
d    3.0
dtype: float64
>>> obj[['b','a','d']]
b    1.0
a    0.0
d    3.0
dtype: float64
>>> obj[[1,3]]
b    1.0
d    3.0
dtype: float64
>>> obj[obj<2]
a    0.0
b    1.0
dtype: float64

利用标签的切片运算与普通的python切片不同，其末端是包含的
>>> obj['b':'c']=5
>>> obj
a    0.0
b    5.0
c    5.0
d    3.0
dtype: float64


>>> data=DataFrame(np.arange(16).reshape((4,4)),
... index=['Ohio', 'Colorado', 'Utah', 'New York'],
... columns=['one','two','three','four'])
>>> data
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15
>>> data['two']
Ohio         1
Colorado     5
Utah         9
New York    13
Name: two, dtype: int32
>>> data[['three','one']]
          three  one
Ohio          2    0
Colorado      6    4
Utah         10    8
New York     14   12


>>> data=DataFrame(np.arange(16).reshape((4,4)),
... index=['Ohio', 'Colorado', 'Utah', 'New York'],
... columns=['one','two','three','four'])
>>> data
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15
>>> data['two']	# 选取DataFrame中的列
Ohio         1
Colorado     5
Utah         9
New York    13
Name: two, dtype: int32
>>> data[['three','one']]	# 选取DataFrame中的两列
          three  one
Ohio          2    0
Colorado      6    4
Utah         10    8
New York     14   12
>>> data[:2]			# 选取data中的两行
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
>>> data[data['three']>5]	# 布尔运算
          one  two  three  four
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15


这段代码的目的是使DataFrame在语法上更像ndarray
>>> data<5
            one    two  three   four
Ohio       True   True   True   True
Colorado   True  False  False  False
Utah      False  False  False  False
New York  False  False  False  False
>>>
>>>
>>>
>>> data[data<5]=0
>>> data
          one  two  three  four
Ohio        0    0      0     0
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15


为了在DataFrame的行上进行标签索引，引入专门的索引字段ix

>>> data
          one  two  three  four
Ohio        0    0      0     0
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15
>>> data.ix['Colorado', ['two', 'three']]	# Colorado行， two列和three列
two      5
three    6
Name: Colorado, dtype: int32
>>> data.ix[['Colorado','Utah'],[3, 0, 1]]	# Colorado，Utah行以及3,0,1列
          four  one  two
Colorado     7    0    5
Utah        11    8    9


>>> data
          one  two  three  four
Ohio        0    0      0     0
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15
>>> data.ix[2]					# 选取第三行
one       8
two       9
three    10
four     11
Name: Utah, dtype: int32


>>> data.ix[:'Utah', 'two']			# 从第一行到Utah行的第二列
Ohio        0
Colorado    5
Utah        9


>>> data.ix[data.three > 5, :3]			# three列大于5的行，第一列到第三列
          one  two  three
Colorado    0    5      6
Utah        8    9     10
New York   12   13     14
>>> data
          one  two  three  four
Ohio        0    0      0     0
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15
>>> data.ix[data.three > 5, :1]
          one
Colorado    0
Utah        8
New York   12
>>> data.ix[data.three > 5, :0]
Empty DataFrame
Columns: []
Index: [Colorado, Utah, New York]


算术运算和数据对齐
>>> s1=Series([7.3, -2.5, 3.4, 1.5], index=['a', 'c', 'd', 'e'])
>>> s2=Series([-2.1, 3.6, -1.5, 4, 3.1], index=['a', 'c', 'e', 'f' ,'g'])
>>> s1+s2	# 如果直接相加，非重叠部分会显示NaN
a    5.2
c    1.1
d    NaN
e    0.0
f    NaN
g    NaN
dtype: float64
>>> s1.add(s2, fill_value=0)	# add方法以及fill_value参数
a    5.2
c    1.1
d    3.4
e    0.0
f    4.0
g    3.1
dtype: float64


DataFrame和Series之间的运算
>>> arr=np.arange(12.).reshape((3,4))
>>> arr
array([[  0.,   1.,   2.,   3.],
       [  4.,   5.,   6.,   7.],
       [  8.,   9.,  10.,  11.]])
>>> arr[0]
array([ 0.,  1.,  2.,  3.])
>>> arr-arr[0]
array([[ 0.,  0.,  0.,  0.],
       [ 4.,  4.,  4.,  4.],
       [ 8.,  8.,  8.,  8.]])


>>> frame=DataFrame(np.arange(12.).reshape((4,3)),columns=list('bde'),
... index=['Utah', 'Ohio', 'Texas', 'Oregon'])
>>> series=frame.ix[0]
>>> frame
          b     d     e
Utah    0.0   1.0   2.0
Ohio    3.0   4.0   5.0
Texas   6.0   7.0   8.0
Oregon  9.0  10.0  11.0
>>> series
b    0.0
d    1.0
e    2.0
Name: Utah, dtype: float64
>>> frame-series
          b    d    e
Utah    0.0  0.0  0.0
Ohio    3.0  3.0  3.0
Texas   6.0  6.0  6.0
Oregon  9.0  9.0  9.0
>>> series2=Series(range(3), index=['b', 'e', 'f'])
>>> frame+series2
          b   d     e   f
Utah    0.0 NaN   3.0 NaN
Ohio    3.0 NaN   6.0 NaN
Texas   6.0 NaN   9.0 NaN
Oregon  9.0 NaN  12.0 NaN
>>> series3=frame['d']
>>> frame
          b     d     e
Utah    0.0   1.0   2.0
Ohio    3.0   4.0   5.0
Texas   6.0   7.0   8.0
Oregon  9.0  10.0  11.0
>>> series3
Utah       1.0
Ohio       4.0
Texas      7.0
Oregon    10.0
Name: d, dtype: float64
>>> frame.sub(series3)
        Ohio  Oregon  Texas  Utah   b   d   e
Utah     NaN     NaN    NaN   NaN NaN NaN NaN
Ohio     NaN     NaN    NaN   NaN NaN NaN NaN
Texas    NaN     NaN    NaN   NaN NaN NaN NaN
Oregon   NaN     NaN    NaN   NaN NaN NaN NaN
>>> frame.sub(series3, axis=0)	# 匹配行 且在列广播
          b    d    e
Utah   -1.0  0.0  1.0
Ohio   -1.0  0.0  1.0
Texas  -1.0  0.0  1.0
Oregon -1.0  0.0  1.0


###函数应用和映射###

对DataFrame中各个元素，或一行/列数据进行函数操作
>>> frame=DataFrame(np.random.randn(4,3), columns=list('bde'),
... index=['Utah', 'Ohio', 'Texas', 'Oregon'])
>>> frame
               b         d         e
Utah   -1.766152 -2.626653 -0.445074
Ohio   -0.292650  0.801737 -0.572183
Texas  -2.034327 -1.394547 -0.839812
Oregon  0.067651  0.847935 -0.979156
>>> np.abs(frame)	# NumPy的ufuns（元素级数组方法）也可用于操作pandas对象
               b         d         e
Utah    1.766152  2.626653  0.445074
Ohio    0.292650  0.801737  0.572183
Texas   2.034327  1.394547  0.839812
Oregon  0.067651  0.847935  0.979156


>>> f = lambda x: x.max()-x.min()	# DataFrame的apply方法即可实现将函数应用到由
>>> frame.apply(f)			# apply（）各列和行所形成的一维数组上
b    2.101978
d    3.474588
e    0.534083
dtype: float64
>>> frame.apply(f, axis=1)
Utah      2.181580
Ohio      1.373920
Texas     1.194515
Oregon    1.827091
dtype: float64


>>> def f(x):
...     return Series([x.min(), x.max()], index=['min', 'max'])
...
>>> frame.apply(f)			# 传递给apply的函数返回由多个值组成的Series
            b         d         e
min -2.034327 -2.626653 -0.979156
max  0.067651  0.847935 -0.445074


>>> format = lambda x: '%.2f' % x	# 得到frame中各个浮点值的格式化字符串用applymap
>>> frame.applymap(format)
            b      d      e
Utah    -1.77  -2.63  -0.45
Ohio    -0.29   0.80  -0.57
Texas   -2.03  -1.39  -0.84
Oregon   0.07   0.85  -0.98


>>> frame['e'].map(format)	# Series有一个用于应用元素级函数的map方法

Utah      -0.45
Ohio      -0.57
Texas     -0.84
Oregon    -0.98
Name: e, dtype: object


###排序和排名###
>>> obj = Series(range(4), index=['d', 'a', 'b', 'c'])
>>> obj
d    0
a    1
b    2
c    3
dtype: int64

>>> obj.sort_index()
a    1
b    2
c    3
d    0
dtype: int64

>>> frame=DataFrame(np.arange(8).reshape((2,4)), index=['three', 'one'],	# 对于DataFrame，则可以根据任意一个轴上的索引进行排序
... columns=['d', 'a', 'b', 'c'])
>>>
>>>
>>> frame
       d  a  b  c
three  0  1  2  3
one    4  5  6  7
>>> frame.sort_index()
       d  a  b  c
one    4  5  6  7
three  0  1  2  3
>>> frame.sort_index(axis=1)
       a  b  c  d
three  1  2  3  0
one    5  6  7  4


>>> frame.sort_index(axis=1, ascending=False)		# 降序排列
       d  c  b  a
three  0  3  2  1
one    4  7  6  5



>>> obj=Series([4, 7, -3, 2])
>>> obj
0    4
1    7
2   -3
3    2
dtype: int64
>>> obj.order()						# Series排序需要用order
2   -3
3    2
0    4
1    7
dtype: int64
>>> obj.order(ascending=False)
1    7
0    4
3    2
2   -3
dtype: int64


>>> obj = Series([4, np.nan, 7, np.nan, -3, 2])		# 任何缺失值默认都会放到Series的末尾
>>> obj.order()						# 无论是Series还是DataFrame
4   -3.0
5    2.0
0    4.0
2    7.0
1    NaN
3    NaN
dtype: float64
>>> obj.order(ascending=False)
2    7.0
0    4.0
5    2.0
4   -3.0
1    NaN
3    NaN
dtype: float64


>>> frame=DataFrame({'b':[4, 7, -3, 2], 'a':[0,1,0,1]})
>>> frame
   a  b
0  0  4
1  1  7
2  0 -3
3  1  2
>>> frame.sort_index(by='b')	# 根据一个或多个列中的值进行排序。将一个或多个列的名字传递给by选项
   a  b
2  0 -3
3  1  2
0  0  4
1  1  7


>>> frame.sort_index(by=['b','a'])	# 先排b列 再排a列
   a  b
2  0 -3
3  1  2
0  0  4
1  1  7
>>> frame.sort_index(by=['a','b'])	# 先排a列 再排b列
   a  b
2  0 -3
0  0  4
3  1  2
1  1  7


排名（ranking）跟排序关系密切
>>> obj=Series([1,1,1,1,1,1])	# 从1开始，然后相同的数取平均数。
>>> obj.rank()
0    3.5
1    3.5
2    3.5
3    3.5
4    3.5
5    3.5
dtype: float64

>>> obj.rank()			# 从1开始，然后相同的数取平均数。
0    6.5
1    1.0
2    6.5
3    4.5
4    3.0
5    2.0
6    4.5
dtype: float64
>>> obj.rank(method='first')	#根据值在原数据中出现的顺序给出排名
0    6.0
1    1.0
2    7.0
3    4.0
4    3.0
5    2.0
6    5.0
dtype: float64
>>> obj.rank(ascending=False, method='max')	# 降序排名 max使用分组中的最大排名
0    2.0
1    7.0
2    2.0
3    4.0
4    5.0
5    6.0
6    4.0
dtype: float64

>>> frame= DataFrame({'b':[4.3, 7, -3, 2], 'a':[0, 1, 0, 1], 'c':[-2, 5, 8, -2.5]})
>>> frame
   a    b    c
0  0  4.3 -2.0
1  1  7.0  5.0
2  0 -3.0  8.0
3  1  2.0 -2.5
>>> frame.rank(axis=1)
     a    b    c
0  2.0  3.0  1.0
1  1.0  3.0  2.0
2  2.0  1.0  3.0
3  2.0  3.0  1.0


###带有重复值的轴索引###
>>> obj=Series(range(5), index=['a', 'a', 'b', 'b', 'c'])
>>> obj
a    0
a    1
b    2
b    3
c    4
dtype: int64
>>> obj.index.is_unique
False

>>> obj['a']		# 如果某个索引对应多个值，则返回一个Series
a    0
a    1
dtype: int64
>>> obj['c']		# 对应单个值，则返回一个标量值
4

>>> df = DataFrame(np.random.randn(4, 3), index=['a', 'a', 'b', 'b'])
>>> df
          0         1         2
a -0.761022  0.228550 -1.123073
a  0.668955 -1.197281 -0.328058
b -0.038427  2.159243  0.187048
b -0.588112  0.232811  0.859724
>>> df.ix['b']
          0         1         2
b -0.038427  2.159243  0.187048
b -0.588112  0.232811  0.859724


汇总和计算描述统计
>>> from pandas import DataFrame
>>> import numpy as np
>>> df=DataFrame([[1.4, np.nan], [7.1, -4.5], [np.nan, np.nan], [0.75, -1.3]],
... index=['a', 'b', 'c', 'd'], columns=['one', 'two'])
>>> df
    one  two
a  1.40  NaN
b  7.10 -4.5
c   NaN  NaN
d  0.75 -1.3
>>> df.sum()	# 按列进行求和
one    9.25
two   -5.80
dtype: float64
>>> df.sum(axis=1)	# 按行进行求和
a    1.40
b    2.60
c     NaN
d   -0.55
dtype: float64


>>> df
    one  two
a  1.40  NaN
b  7.10 -4.5
c   NaN  NaN
d  0.75 -1.3
>>> df.mean(axis=1, skipna=False)		# 禁止对于Na值的排除
a      NaN
b    1.300
c      NaN
d   -0.275
dtype: float64
>>> df.mean(axis=1)				# 
a    1.400
b    1.300
c      NaN
d   -0.275
dtype: float64










