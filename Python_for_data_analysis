###################################
###numpy基础：数组和矢量的计算#####
###################################


创建ndarray
>>> import numpy as np
>>> data1 = [6, 7.5, 8, 0, 1]
>>> arr1 = np.array(data1)	# 使用array函数，它接受一切序列型的对象，产生一个含有传入数据的numpy数组
>>> arr1
array([ 6. ,  7.5,  8. ,  0. ,  1. ])


嵌套序列
>>> data2 = [[1,2,3,4], [5, 6, 7, 8]]
>>> arr2 = np.array(data2)
>>> arr2
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])
>>> arr2.ndim	# 数组的维数
2
>>> arr2.shape	# 2行4列的数组
(2, 4)

>>> arr1.dtype	# 数据类型保存在一个特殊的dtype对象中
dtype('float64')
>>> arr2.dtype
dtype('int32')


其它函数新建数组
>>> np.zeros(10)	# 生成全是0的数组
array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
>>> np.zeros((3, 6))
array([[ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.]])
>>> np.ones((3, 6))	# 生成全是1的数组
array([[ 1.,  1.,  1.,  1.,  1.,  1.],
       [ 1.,  1.,  1.,  1.,  1.,  1.],
       [ 1.,  1.,  1.,  1.,  1.,  1.]])
>>> np.empty((2, 3, 2))		# 生成的不是0， 是一些未被处理的垃圾值
array([[[  1.03510883e-295,   6.38742701e-314],
        [  1.55420853e-285,   1.27319747e-313],
        [  1.27319747e-313,   1.27319747e-313]],

       [[  2.37332014e-286,   1.91205622e-313],
        [  8.13462439e-296,   2.75859453e-313],
        [  2.48324480e-286,   3.12237178e-120]]])

>>> np.arange(15)		# arange是python内置函数range的数组版
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])

>>> np.eye(3)			# 对角线是1的数组
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])


ndarray的数据类型
>>> arr1 = np.array([1, 2, 3], dtype=np.float64)
>>> arr2 = np.array([1, 2, 3], dtype=np.int32)
>>> arr1.dtype
dtype('float64')
>>> arr2.dtype
dtype('int32')



数组和标量之间的运算
>>> arr = np.array([[1., 2., 3.], [4., 5., 6.]])
>>> arr
array([[ 1.,  2.,  3.],
       [ 4.,  5.,  6.]])
>>> arr*arr
array([[  1.,   4.,   9.],	#大小相等的数组的任何运算都会将运算运用到元素级
       [ 16.,  25.,  36.]])
>>> 1/arr
array([[ 1.        ,  0.5       ,  0.33333333],
       [ 0.25      ,  0.2       ,  0.16666667]])
>>> arr**0.5
array([[ 1.        ,  1.41421356,  1.73205081],
       [ 2.        ,  2.23606798,  2.44948974]])

>>> a = np.array([[1,2],[1,2]])	#矩阵的运算需要dot函数
>>> np.dot(a,a)
array([[3, 6],
       [3, 6]])


基本的索引和切片
>>> import numpy as np
>>> arr = np.arange(10)
>>> arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>>
>>>
>>> arr[5]
5
>>>
>>> arr[5:8]
array([5, 6, 7])
>>> arr[5:8] = 12
>>> arr
array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9]) # 当一个标量值赋值给一个切片时，该值会自动传播到整个选取


>>> arr_slice = arr[5:8]
>>> arr_slice[1] = 12345
>>> arr
array([    0,     1,     2,     3,     4,    12, 12345,    12,     8,     9])
>>> arr_slice[:] = 64
>>> arr
array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])


>>> arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])	# 多维数组索引
>>> arr2d[2]
array([7, 8, 9])
>>> arr2d[0][2]
3
>>> arr2d[0, 2]
3


>>> arr3d = np.array([[[1, 2, 3], [4, 5, 6]],[[7, 8, 9], [10, 11, 12]]])
>>> arr3d	# 括号外面的“维度”是一维，二维，。。。而括号里面的应该理解为“轴”--类比三维数组
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
>>> arr3d [0]
array([[1, 2, 3],
       [4, 5, 6]])



>>> old_values = arr3d[0].copy()
>>>
>>> arr3d[0] = 42
>>> arr3d
array([[[42, 42, 42],
        [42, 42, 42]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
>>> arr3d[0] = old_values	# 标量和数组都可以被赋值给arr3d[0]
>>> arr3d
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

>>> arr3d[1, 0]
array([7, 8, 9])

切片索引

>>> arr
array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])
>>> arr[1:6]
array([ 1,  2,  3,  4, 64])


>>> arr2d
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
>>> arr2d[:2]	#[:2]意思是--第0项和第1项
array([[1, 2, 3],
       [4, 5, 6]])
>>> arr2d[:2, 1:]	# [1:] 第一项到最后
array([[2, 3],
       [5, 6]])


>>> arr2d[1, :2]
array([4, 5])
>>> arr2d[2, :1]
array([7])
>>> arr2d[:, :1]	
array([[1],
       [4],
       [7]])
>>> arr2d[:2, 1:]
array([[2, 3],
       [5, 6]])
>>> arr2d[:2, 1:] = 0	#对切片表达式的赋值操作也会被扩赛到整个选区
>>> arr2d
array([[1, 0, 0],
       [4, 0, 0],
       [7, 8, 9]])


布尔型索引

>>> data = np.random.randn(7, 4)
>>> data
array([[-0.31042535, -2.17572506,  0.56252532,  0.99534791],
       [ 0.63397486, -0.13189191,  0.29471484,  0.50351773],
       [ 0.51495017,  0.04994144, -0.1762269 , -0.19449053],
       [-0.07743183, -0.42964157, -1.39686796, -1.11814711],
       [-1.13909174, -0.65366514, -0.2169853 ,  0.61072596],
       [ 1.41913738, -1.2421399 ,  0.45052187, -0.17214591],
       [-0.14628746,  0.25535978, -1.04384285,  0.45418343]])
>>> names
array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
      dtype='|S4')
>>> names == 'Bob'
array([ True, False, False,  True, False, False, False], dtype=bool)
>>> data[names ==  'Bob']	# 布尔型数组可用于数组索引，布尔型数组的长度必须跟被索引的轴长度一致
array([[-0.31042535, -2.17572506,  0.56252532,  0.99534791],
       [-0.07743183, -0.42964157, -1.39686796, -1.11814711]])


>>> data[names ==  'Bob', 2:]	# 布尔型数组跟切片混合使用
array([[ 0.56252532,  0.99534791],
       [-1.39686796, -1.11814711]])

>>> data[names ==  'Bob', 3]
array([ 0.99534791, -1.11814711])

>>> names != 'Bob'	# 选择除“Bob”以外的其他值可以使用不等于符号(!=),也可以通过负号
array([False,  True,  True, False,  True,  True,  True], dtype=bool)
>>> data[-(names ==  'Bob')]
array([[ 0.63397486, -0.13189191,  0.29471484,  0.50351773],
       [ 0.51495017,  0.04994144, -0.1762269 , -0.19449053],
       [-1.13909174, -0.65366514, -0.2169853 ,  0.61072596],
       [ 1.41913738, -1.2421399 ,  0.45052187, -0.17214591],
       [-0.14628746,  0.25535978, -1.04384285,  0.45418343]])


>>> mask = (names == 'Bob')|(names == 'Will')
>>> mask
array([ True, False,  True,  True,  True, False, False], dtype=bool)
>>> mask1 = (names == 'Bob') & (names == 'Will')
>>> mask1
array([False, False, False, False, False, False, False], dtype=bool)
>>> data[mask]
array([[-0.31042535, -2.17572506,  0.56252532,  0.99534791],
       [ 0.51495017,  0.04994144, -0.1762269 , -0.19449053],
       [-0.07743183, -0.42964157, -1.39686796, -1.11814711],
       [-1.13909174, -0.65366514, -0.2169853 ,  0.61072596]])


>>> data
array([[-0.31042535, -2.17572506,  0.56252532,  0.99534791],
       [ 0.63397486, -0.13189191,  0.29471484,  0.50351773],
       [ 0.51495017,  0.04994144, -0.1762269 , -0.19449053],
       [-0.07743183, -0.42964157, -1.39686796, -1.11814711],
       [-1.13909174, -0.65366514, -0.2169853 ,  0.61072596],
       [ 1.41913738, -1.2421399 ,  0.45052187, -0.17214591],
       [-0.14628746,  0.25535978, -1.04384285,  0.45418343]])
>>>
>>> data[data < 0] = 0	#将data中的所有负值都设置为0
>>> data
array([[ 0.        ,  0.        ,  0.56252532,  0.99534791],
       [ 0.63397486,  0.        ,  0.29471484,  0.50351773],
       [ 0.51495017,  0.04994144,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.61072596],
       [ 1.41913738,  0.        ,  0.45052187,  0.        ],
       [ 0.        ,  0.25535978,  0.        ,  0.45418343]])

>>> data[names != 'Joe'] = 7	#
>>> data
array([[ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 0.63397486,  0.        ,  0.29471484,  0.50351773],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 1.41913738,  0.        ,  0.45052187,  0.        ],
       [ 0.        ,  0.25535978,  0.        ,  0.45418343]])


花式索引
>>> arr = np.empty((8,4))
>>> for i in range(8):
...     arr[i] = i
...
>>> arr
array([[ 0.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  1.],
       [ 2.,  2.,  2.,  2.],
       [ 3.,  3.,  3.,  3.],
       [ 4.,  4.,  4.,  4.],
       [ 5.,  5.,  5.,  5.],
       [ 6.,  6.,  6.,  6.],
       [ 7.,  7.,  7.,  7.]])
>>> arr[[4, 3, 0, 6]]	# 第四行，第三行，第零行 和 第六行
array([[ 4.,  4.,  4.,  4.],
       [ 3.,  3.,  3.,  3.],
       [ 0.,  0.,  0.,  0.],
       [ 6.,  6.,  6.,  6.]])

>>> arr[[-3, -5, 0, -7]]	#使用负数索引将会从末尾开始选取行
array([[ 5.,  5.,  5.,  5.],
       [ 3.,  3.,  3.,  3.],
       [ 0.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  1.]])


>>> arr = np.arange(32).reshape((8, 4)) # 一次传入多个索引数组，它返回的是一个一维数组，其中的元素对应各个索引元组
>>> arr
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])
>>> arr[[1, 5, 7, 2],[0, 3, 1, 2]]
array([ 4, 23, 29, 10])

>>> arr[[1, 5, 7, 2]][:,[0, 3, 1, 2]]	# 先取行，再取列
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])



数组转置和轴对换
>>> arr = np.arange(15).reshape((3, 5))
>>> arr
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
>>> arr.T
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])



>>> arr = np.arange(16).reshape((2, 2, 4))
>>> arr
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
>>> arr.transpose((1, 0, 2))
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])
>>> arr.transpose((1, 2, 0))
array([[[ 0,  8],
        [ 1,  9],
        [ 2, 10],
        [ 3, 11]],

       [[ 4, 12],
        [ 5, 13],
        [ 6, 14],
        [ 7, 15]]])

我说你来试一下哈：
arr1.shape 应该是(2, 2, 4) 意为 2维，2*4矩阵

arr1.transpose(*args) 里面的参数，可以这么理解，他是调换arr1.shape的顺序，咱来给arr1.shape标一下角标哈，（2[0], 2[1], 4[2]）  [ ] 里是shape的索引，对吧， 
transpose((1, 0, 2)) 的意思是 按照这个顺序 重新设置shape 也就是 （2[1], 2[0], 4[2]）

 虽然看起来 变换前后的shape都是 2,2,4  ， 但是问题来了，transpose是转置
shape按照(1,0,2)的顺序重新设置了， array里的所有元素 也要按照这个规则重新组成新矩阵

 比如 8 在arr1中的索引是 (1, 0, 0)  那么按照刚才的变换规则，就是 (0, 1, 0) 看看跟你结果arr2的位置一样了吧，依此类推...













