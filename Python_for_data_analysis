###################################
###numpy基础：数组和矢量的计算#####
###################################


创建ndarray
>>> import numpy as np
>>> data1 = [6, 7.5, 8, 0, 1]
>>> arr1 = np.array(data1)	# 使用array函数，它接受一切序列型的对象，产生一个含有传入数据的numpy数组
>>> arr1
array([ 6. ,  7.5,  8. ,  0. ,  1. ])


嵌套序列
>>> data2 = [[1,2,3,4], [5, 6, 7, 8]]
>>> arr2 = np.array(data2)
>>> arr2
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])
>>> arr2.ndim	# 数组的维数
2
>>> arr2.shape	# 2行4列的数组
(2, 4)

>>> arr1.dtype	# 数据类型保存在一个特殊的dtype对象中
dtype('float64')
>>> arr2.dtype
dtype('int32')


其它函数新建数组
>>> np.zeros(10)	# 生成全是0的数组
array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
>>> np.zeros((3, 6))
array([[ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.]])
>>> np.ones((3, 6))	# 生成全是1的数组
array([[ 1.,  1.,  1.,  1.,  1.,  1.],
       [ 1.,  1.,  1.,  1.,  1.,  1.],
       [ 1.,  1.,  1.,  1.,  1.,  1.]])
>>> np.empty((2, 3, 2))		# 生成的不是0， 是一些未被处理的垃圾值
array([[[  1.03510883e-295,   6.38742701e-314],
        [  1.55420853e-285,   1.27319747e-313],
        [  1.27319747e-313,   1.27319747e-313]],

       [[  2.37332014e-286,   1.91205622e-313],
        [  8.13462439e-296,   2.75859453e-313],
        [  2.48324480e-286,   3.12237178e-120]]])

>>> np.arange(15)		# arange是python内置函数range的数组版
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])

>>> np.eye(3)			# 对角线是1的数组
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])


ndarray的数据类型
>>> arr1 = np.array([1, 2, 3], dtype=np.float64)
>>> arr2 = np.array([1, 2, 3], dtype=np.int32)
>>> arr1.dtype
dtype('float64')
>>> arr2.dtype
dtype('int32')



数组和标量之间的运算
>>> arr = np.array([[1., 2., 3.], [4., 5., 6.]])
>>> arr
array([[ 1.,  2.,  3.],
       [ 4.,  5.,  6.]])
>>> arr*arr
array([[  1.,   4.,   9.],	#大小相等的数组的任何运算都会将运算运用到元素级
       [ 16.,  25.,  36.]])
>>> 1/arr
array([[ 1.        ,  0.5       ,  0.33333333],
       [ 0.25      ,  0.2       ,  0.16666667]])
>>> arr**0.5
array([[ 1.        ,  1.41421356,  1.73205081],
       [ 2.        ,  2.23606798,  2.44948974]])

>>> a = np.array([[1,2],[1,2]])	#矩阵的运算需要dot函数
>>> np.dot(a,a)
array([[3, 6],
       [3, 6]])


基本的索引和切片
>>> import numpy as np
>>> arr = np.arange(10)
>>> arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>>
>>>
>>> arr[5]
5
>>>
>>> arr[5:8]
array([5, 6, 7])
>>> arr[5:8] = 12
>>> arr
array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9]) # 当一个标量值赋值给一个切片时，该值会自动传播到整个选取


>>> arr_slice = arr[5:8]
>>> arr_slice[1] = 12345
>>> arr
array([    0,     1,     2,     3,     4,    12, 12345,    12,     8,     9])
>>> arr_slice[:] = 64
>>> arr
array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])


>>> arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])	# 多维数组索引
>>> arr2d[2]
array([7, 8, 9])
>>> arr2d[0][2]
3
>>> arr2d[0, 2]
3


>>> arr3d = np.array([[[1, 2, 3], [4, 5, 6]],[[7, 8, 9], [10, 11, 12]]])
>>> arr3d	# 括号外面的“维度”是一维，二维，。。。而括号里面的应该理解为“轴”--类比三维数组
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
>>> arr3d [0]
array([[1, 2, 3],
       [4, 5, 6]])



>>> old_values = arr3d[0].copy()
>>>
>>> arr3d[0] = 42
>>> arr3d
array([[[42, 42, 42],
        [42, 42, 42]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
>>> arr3d[0] = old_values	# 标量和数组都可以被赋值给arr3d[0]
>>> arr3d
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

>>> arr3d[1, 0]
array([7, 8, 9])

切片索引

>>> arr
array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])
>>> arr[1:6]
array([ 1,  2,  3,  4, 64])


>>> arr2d
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
>>> arr2d[:2]	#[:2]意思是--第0项和第1项
array([[1, 2, 3],
       [4, 5, 6]])
>>> arr2d[:2, 1:]	# [1:] 第一项到最后
array([[2, 3],
       [5, 6]])


>>> arr2d[1, :2]
array([4, 5])
>>> arr2d[2, :1]
array([7])
>>> arr2d[:, :1]	
array([[1],
       [4],
       [7]])
>>> arr2d[:2, 1:]
array([[2, 3],
       [5, 6]])
>>> arr2d[:2, 1:] = 0	#对切片表达式的赋值操作也会被扩赛到整个选区
>>> arr2d
array([[1, 0, 0],
       [4, 0, 0],
       [7, 8, 9]])










