Enter file contents here#######################################
#################函数##################
#######################################

def <名字> (arg1，arg2，。。。，argN）
	<语句>
return <值>

>>> def times(x,y): # 生成并赋值函数
...     return x*y  # 在调用的时候函数体执行
...
>>> times(5,5)	# 括号内的参数
25
>>> times(5,5.5) # 函数是“无类型的”
27.5
>>> times('Ni',4)
'NiNiNiNi'



>>> def intersect(seq1, seq2):
...     res=[]		# 开始为空
...     for x in seq1:	# 扫描seq1
...             if x in seq2:	# 公共项？
...                     res.append(x)	#添加到尾部
...     return res
...
>>> s1='SPAM'
>>> s2='SCAM'
>>> intersect(s1,s2)	# 字符串
['S', 'A', 'M']
>>> intersect([1,2,3],(1,2,4))	# 混合类型
[1, 2]


--函数中的作用域规则--
>>> x=99	# x和func在模块中被赋值：全局的
>>> def func(Y):	# Y和Z在函数中被赋值：局部的
...     Z=x+Y		# x没被赋值，所以是全局的
...     return Z
...
>>> func(1)
100

>>> y,z=1,2		# 模块中的全局变量
>>> def all_global():
...     global x	# 声明全局的赋值
...     x=y+z
...     return x	# 无需声明y，z 作用域规则
...
>>> all_global()
3
>>> x
3


--参数传递--
参数通过局部名字传递
	函数参数现在已经是我们熟悉的领域了：它们只是工作中Python赋值的
	又一个例子而已。函数参数（可能）是对共享对象的引用，被调用者所引用。

在一个函数中对参数名赋值不影响调用者
	函数首部中的参数名当函数运行时在作用域中成为新的局部名字。函数的参
	数名字不是调用者使用的名字的别名。

在一个函数中改变一个可变的对象参数可能影响调用者
	在另一个方面，既然参数只是简单的赋值给对象，函数能改变被传递的可变
	对象，结果可能影响调用者


>>> def changer(x,y):
...     x=2	# 只改变局部的名字值，数字是不可改变的，因此新生成的局部变量指向全局变量的值
...     y[0]='spam'	# 列表是可变的，在该位置改变共享对象
...
>>> x=1
>>> l=[1,2]
>>> changer(x,l)
>>>
>>> x,l
(1, ['spam', 2])

http://winterttr.me/2015/10/24/python-passing-arguments-as-value-or-reference/
http://www.jb51.net/article/63416.htm


--return的应用--
return可以返回任何种类的对象，通过在一个元组中
打包它们，它可以返回多个值。

>>> x=1
>>> L=[1,2]
>>> x,L=multiple(x,L)
>>> x,L
(1, [1, 2])

>>> def multiple(x,y):
...     x=2	# 只改变局部名
...     y=[3,4]
...     return x,y	# 在一个元组中返回新值
...
>>> x=1
>>> L=[1,2]
>>> x,L=multiple(x,L)	# 对调用者的名字赋值结果
>>> x,L
(2, [3, 4])


--特殊参数匹配模式--

#example1
>>> def func(spam,eggs,toast=0,ham=0):
...     print(spam,eggs,toast,ham)
...
>>> func(1,2)
(1, 2, 0, 0)
>>> func(1,ham=4,eggs=0) # python通过名字而不是位置匹配，调用者必须为spam和eggs提供值，但它们可以通过位置或名字匹配。
(1, 0, 0, 4)
>>> func(spam=4,eggs=0)
(4, 0, 0, 0)
>>> func(toast=1,eggs=2,spam=3)
(3, 2, 1, 0)
>>> func(1,2,3,4)
(1, 2, 3, 4)

#example1
whwu@master:~/script> cat inter2.py
def intersect(*args):		# 通过*args收集所有的参数
        res=[]
        for x in args[0]:
                for other in args[1:]:
                        if x not in other:
                                break
                else:
                        res.append(x)
        return res


def union(*args):
        res=[]
        for seq in args:
                for x in seq:
                        if not x in res:
                                res.append(x)
        return res

>>> from inter2 import intersect,union
>>> s1,s2,s3="SPAM","SCAM","SLAM"
>>> intersect(s1,s2,s3),union(s1,s2,s3)
(['S', 'A', 'M'], ['S', 'P', 'A', 'M', 'C', 'L'])







